{"pages":[],"posts":[{"title":"何为Docker","text":"Docker简介基于Go语言开发的开源项目 官网：https://www.docker.com/ 文档地址：https://docs.docker.com/ 仓库地址：https://hub.docker.com/ Docker为什么会出现？ 叶檀财经：开发 —&gt; 上线 两套环境！ 开发 ··· 运维 问题：项目在我的电脑上可以运行 环境配置是十分麻烦的，每一个机器都需要部署集群，费时费力 我们发布一个（jar + （Redis、Mysql、jdk … ）），项目能不能都带上环境打包部署 传统：开发jar，部署上线运维来做 现在：开发打包部署上线一条龙服务 Docker 给以上问题，提出了解决方案 Docker的核心思想 隔离机制： 例子：水果，生化武器 通过隔离机制，可以将服务器利用到极致 Docker的历史2010年，几位怀揣着梦想的年轻人，创立了一家公司DotCloud，公司起初做的业务为即”DotCloud Paas”平台即服务供应商，底层技术上，dotCloud采用了Linux容器技术。为了方便创建和管理这些容器，dotCloud开发了一套自己的内部工具，Docker这就这样诞生的! 2013年，dotCloud业务发展并不景气，为了寻求新的突破，将Docker开源并公司重新命名为Docker，放弃了dotCloud平台，怀揣着”将Docker和容器技术推向全世界”的使命，开启了一段新的征程。 2014年，Docker1.0发布。 2018年，公司估值已为惊人的13亿美元。 Docker为什么这么火？Docker与传统虚拟机Vmware类比： VM：隔离 需要开启多个虚拟机 每个虚拟机大小为几G不等 启动时间长达”几分钟” Docker：隔离 镜像(最核心的环境 4m + jdk + mysql …)十分小巧，运行镜像就可以了 启动时间为”秒级” Docker与JVM类比： JVM：一次编译到处运行 Docker：一次构建到处运行 Docker能干嘛?应用更快速的交付和部署 传统：环境部署，一堆帮助文档，安装配置运行 Docker：打包发布镜像测试，一键运行 更便捷的升级和扩缩容 使用Docker之后，部署应用升级就好比搭积木。 项目打包为一个镜像，需要扩展就直接复制粘贴到另一个服务器。 更简单的系统运维： 容器化之后，我们的开发、测试环境都是高度一致的。 更高效的计算机资源利用： Docker是内核级别的虚拟化，可以在一个服务器上运行很多容器实例，把服务器性能利用到极致。 Docker安装与使用参考文档：http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html 123456789101112131415161718192021222324252627282930313233343536373839404142# 1、需要的安装包yum install -y yum-utils# 2、设置下载镜像的仓库(这里我们使用国内镜像仓库)yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像地址 # 2.1在 vim /etc/docker/daemon.json 添加镜像 {&quot;registry-mirrors&quot;: [&quot;https://7bezldxe.mirror.aliyuncs.com/&quot;,&quot;https://docker.mirrors.ustc.edu.cn/&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://registry.docker-cn.com&quot;]# 3、安装Docker引擎 docker-ce 社区版 | docker-ee 企业版(这里安装最新版本)yum install docker-ce docker-ce-cli containerd.io # 安装指定版本Dockeryum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io# 4、启动与停止Dockersystemctl start dockersystemctl stop docker# 5、查看Docker当前版本号docker --version# 6、启动 hello worlddocker run hello-world1. Unable to find image 'hello-world:latest' locally # 没有找到 hello world2. latest: Pulling from library/hello-world # 自动拉取镜像# 7、查看下载的 hello world 镜像docker images# 8、卸载Docker # 卸载依赖 1. yum remove docker-ce docker-ce-cli containerd.io # 删除资源 2. rm -rf /var/lib/docker # 9、Docker默认工作路径 /var/lib/docker 123 # 列出本机的所有容器文件。docker image lsdocker images 12# 删除容器文件docker image rm [imageName] 123# 查看当前正在运行的容器docker ps 、 # 列出本机正在运行的容器docker ps -a # 列出本机所有容器，包括终止运行的容器 12# 手动从仓库中拉取镜像文件docker image pull library/hello-world # 默认为最新版本 示例 一：安装nginx 123456789101112131415161718192021# 从官网拉取nginx镜像docker pull nginx# 查看镜像库docker images# 使用nginx镜像创建nginx容器实例docker run --name nginx-test -p 8080:80 -d nginx # run 创建容器实例 # -- name 容器命名 # -v 映射目录 # -p 本机端口映射 将容器的80端口映射到本机的80端口 # -d 设置容器后台运行 # 语句最后一个nginx是使用镜像的名称# 停止nginx容器docker stop nginx-test # 启动nginx容器docker start nginx-test 二：将nginx关键目录映射到本机 123456789101112131415161718192021222324252627282930313233# 在本机上创建目录mkdir -p /root/nginx/www /root/nginx/logs /root/nginx/conf # www: nginx存储网站网页的目录 # logs: nginx日志目录 # conf: nginx配置文件目录 # 查看nginx容器IDdocker ps -a# 将docker-test容器配置文件copy到本地docker cp [容器ID]:/etc/nginx/nginx.conf /root/nginx/conf# 创建新容器实例之前需要将当前正在运行的暂停(防止端口冲突)docker stop [容器ID]# 创建新nginx容器nginx-web,并将www,logs,conf目录映射到本地docker run -d -p 8989:80 --name nginx-web -v /root/nginx/www:/usr/share/nginx/html -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/logs:/var/log/nginx nginx# 启动nginxdocker start nginx-web# 在本机&quot;www&quot;创建docker首页 index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;docker&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;docker搭建nginx映射成功&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/07/08/Docker/"},{"title":"Java数据结构之线性表（双向链表）","text":"Java数据结构之线性表（双向链表） 链表结构 链式存储结构是基于指针实现，我们把一个数据元素和一个指针成为节点 链式存储结构是用指针把相互直接关联的结点（即直接前驱节点或直接后继节点）链接起来。 链式存储结构的线性表成为链表 链表类型 根据链表的构造方式的不同可以分为： 1. 单向链表 2. 循环链表 3. 双向链表 线性表的抽象数据类型 1、线性表的置空操作 clear() 2、线性表判空操作： isEmpty() 3、求线性表的长度： size( ) 4、取元素操作： get( i ) 5、插入操作： insert( i, x ) 6、删除操作： delete( i) 双向链表1、基本概念双向链表也叫双链表，是链表的一种，它的每个数据[结点](https://baike.baidu.com/item/结点/9794643)中都有两个[指针](https://baike.baidu.com/item/指针/2878304)，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向[循环链表](https://baike.baidu.com/item/循环链表/3228465)。 2、图形理解![](https://img-blog.csdnimg.cn/img_convert/5e88ad6d0ee77fe76e712e5837678d42.png) 相对于单链表而言,每个节点不仅有一个next，而且有一个指向前一个元素的pre 3、链表特性每个数据结点中都有两个指针，分别指向直接后继和直接前驱 4、优缺点优点 可以找到前驱和后继，可进可退 缺点 增加删除节点复杂，多需要分配一个指针存储空间 优缺点总结 适用于需要双向查找节点值的情况 5、代码展示5.1、基础代码123456789101112131415161718192021222324252627282930313233/** 保存该链表的头结点 */private Node head;/** 保存该链表的尾结点 */private Node tail;/** 保存该链表中已包含的节点数 */private int size;/** 内部类 */private class Node { // 保存节点数据 private T data; // 指向上个节点的引用 private Node prev; // 指向下个节点的引用 private Node next; // 无参构造器 public Node() { } // 初始化构造器 public Node(T data) { this.data = data; } public Node(T data, Node prev) { this.data = data; this.prev = prev; } public Node(T data, Node prev, Node next) { this.data = data; this.prev = prev; this.next = next; }} 5.2、插入数据a、链表为空时123456789101112/** * &lt;p&gt;以指定数据元素来创建链表，Ps.（当前链表为空）&lt;/p&gt; * * @param element 数据 * @author Kallen * @since 2020/12/23 13:33*/public DoubleLink(T element) { head = new Node(element); tail = head; size++;} b、根据索引添加 1234567891011121314151617181920212223242526272829303132333435/** * &lt;p&gt;根据索引插入元素&lt;/p&gt; * * @param element 元素 * @param index 索引 * @author Kallen * @since 2020/12/28 16:05*/public void insert(T element, int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;索引越界&quot;); } // 判断当前链表是否为空 if (head == null) { DoubleLink(element); }else { if (index == 0) { // 当index为0时，即为在链表头插入 addAtHeader(element); }else { // 获取插入点的前一个节点 Node prev = getNodeByIndex(index - 1); // 获取插入点的节点 Node next = prev.next; // 让新节点的next引用指向next节点，prev引用指向prev节点 Node newNode = new Node(element , prev , next); // 让prev的next指向新节点。 prev.next = newNode; // 让prev的下一个节点的prev指向新节点 next.prev = newNode; size++; } }} c、尾插法123456789101112131415161718192021/** * &lt;p&gt;尾插法&lt;/p&gt; * * @param element 元素 * @author Kallen * @since 2020/12/28 16:25*/public void add(T element) { // 如果该链表为空 if (head == null) { DoubleLink(element); }else { // 创建新节点,新节点的pre引用指向原tail节点 Node newNode = new Node(element , tail , null); // 让尾节点的next指向新增的节点 tail.next = newNode; // 以新节点作为新的尾节点 tail = newNode; } size++;} d、头插法1234567891011121314151617/** * &lt;p&gt;头插法&lt;/p&gt; * * @param element 元素 * @author Kallen * @since 2020/12/28 16:10*/public void addAtHeader(T element) { // 创建新节点，让新节点的next指向原来的head，并以新节点作为新的head head = new Node(element, head); // 如果插入之前是空链表 if (tail == null) { tail = head; } size++;} 5.3、查询数据a、根据索引查询1234567891011/** * &lt;p&gt;获取指定索引处的元素&lt;/p&gt; * * @param index 指定索引 * @return {@link T} 元素 * @author Kallen * @since 2020/12/23 13:35*/public T get(int index) { return getNodeByIndex(index).data;} b、根据指定元素查找索引1234567891011121314151617/** * &lt;p&gt;查询指定元素的索引&lt;/p&gt; * * @param element 元素 * @return {@link int} 索引 * @author Kallen * @since 2020/12/25 15:48*/public int locate(T element) { Node current = head; for (int i = 0; i &lt; size &amp;&amp; current != null; i++, current = current.next) { if (current.data.equals(element)) { return i; } } return -1;} c、获取当前链表长度12345678910/** * &lt;p&gt;获取链表长度&lt;/p&gt; * * @return {@link int} 链表长度 * @author Kallen * @since 2020/12/23 13:34*/public int size() { return size;} 5.4、删除数据a、根据索引删除 123456789101112131415161718192021222324252627282930/** * &lt;p&gt;根据索引删除&lt;/p&gt; * * @param index 索引 * @author Kallen * @since 2020/12/28 17:08*/public void delete(int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;索引越界&quot;); } if (index == 0) { head = head.next; head.prev = null; }else { // 获取删除节点的前一个节点 Node prev = getNodeByIndex(index-1); // 让prev节点的next指向被删除节点的next prev.next = prev.next.next; // 让被删除节点的next节点的prev指向prev节点 Ps(被删除节点的next节点不为尾节点) if (prev.next != null) { prev.next.prev = prev; } // 将被删除节点的prev、next引用赋为null prev.next.prev = null; prev.next.next = null; } size--;} b、删除最后一个元素123456789/** * &lt;p&gt;删除链表的最后一个元素&lt;/p&gt; * * @author Kallen * @since 2020/12/28 17:15*/public void remove() { delete(size-1);} 5.5、判断是否为空123456789/** * &lt;p&gt;判断链表是否为空链表&lt;/p&gt; * * @author Kallen * @since 2020/12/28 17:16*/public boolean isEmpty() { return size == 0;} 5.6、清空链表1234567891011/** * &lt;p&gt;清空链表&lt;/p&gt; * * @author Kallen * @since 2020/12/28 17:17*/public void clear() { head = null; tail = null; size = 0;} 5.7、私有方法1234567891011121314151617181920212223242526272829303132/** * &lt;p&gt;根据指定索引获取结点&lt;/p&gt; * * @param index 索引 * @return {@link DoubleLink&lt;T&gt;.Node} 节点 * @author Kallen * @since 2020/12/23 13:36*/private Node getNodeByIndex(int index) { if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;索引越界&quot;); } // 当索引值小于该链表长度的一半时，应从头结点开始搜索，PS（值相同从头结点开始搜索） if (index &lt;= size / 2) { Node current = head; for (int i = 0; i &lt;= size / 2 &amp;&amp; current != null; i++, current = current.next) { if (i == index) { return current; } } }else { // 从tail节点开始搜索 Node current = tail; for (int i = size - 1; i &gt; size / 2 &amp;&amp; current != null; i++, current = current.prev) { if (i == index) { return current; } } } return null;}","link":"/2020/12/29/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"Java数据结构之线性表（单向链表）","text":"Java数据结构之线性表（单向链表） 链表结构 链式存储结构是基于指针实现，我们把一个数据元素和一个指针成为节点 链式存储结构是用指针把相互直接关联的结点（即直接前驱节点或直接后继节点）链接起来。 链式存储结构的线性表成为链表 链表类型 根据链表的构造方式的不同可以分为： 1. 单向链表 2. 循环链表 3. 双向链表 线性表的抽象数据类型 1、线性表的置空操作 clear() 2、线性表判空操作： isEmpty() 3、求线性表的长度： size( ) 4、取元素操作： get( i ) 5、插入操作： insert( i, x ) 6、删除操作： delete( i) 单向链表1、基本概念单向链表（[单链表](https://baike.baidu.com/item/单链表/3228368)）是[链表](https://baike.baidu.com/item/链表/9794473)的一种，其特点是链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始；链表是使用[指针](https://baike.baidu.com/item/指针/2878304)进行构造的列表；又称为结点列表，因为链表是由一个个结点组装起来的；其中每个结点都有指针[成员变量](https://baike.baidu.com/item/成员变量/11024994)指向列表中的下一个结点； 链表是由[结点](https://baike.baidu.com/item/结点/9794643)构成，head指针指向第一个成为表头结点，而终止于最后一个指向[NULL](https://baike.baidu.com/item/NULL/19660387)的指针。 2、图形理解 头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。 有了头结点后，对在第一个元素结点前插入结点和删除第一个结点，其操作与对其它结点的操作统一了。 首元结点也就是第一个元素的结点，它是头结点后边的第一个结点。 头结点不是链表所必需的。 在线性表的链式存储结构中，头指针是指链表指向第一个结点的指针，若链表有头结点，则头指针就是指向链表头结点的指针。 头指针具有标识作用，故常用头指针冠以链表的名字。 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。 单链表也可以没有头结点。 3、链表特性链表的链接方向是单向的 4、优缺点（对比线性表）优点 结点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小 结点的删除非常方便，不需要像线性结构那样移动剩下的数据 结点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表 缺点 只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进 优缺点总结 适用于节点的增加删除 5、代码展示5.1、基础代码123456789101112131415161718192021222324252627/** 保存该链表的头结点 */private Node head;/** 保存该链表的尾结点 */private Node tail;/** 保存该链表中已包含的节点数 */private int size;/** 内部类 */private class Node { // 保存节点的数据 private T date; // 指向下个节点的引用 private Node next; // 无参构造器 public Node() { } // 初始化构造器 public Node(T date) { this.date = date; } public Node(T date, Node next) { this.date = date; this.next = next; }} 5.2、插入数据a、链表为空时 ![链表为空](https://img-blog.csdnimg.cn/img_convert/b29a4abd2bb6c1d0c2aa91cc82b6f5ec.png) 12345678910111213/** * &lt;p&gt;以指定数据元素来创建链表，Ps.（当前链表为空）&lt;/p&gt; * * @param element 数据 * @author Kallen * @since 2020/12/22 13:52*/public void OneLink(T element) { head = new Node(element); // 只有一个节点，head、tail 都指向该节点 tail = head; size++;} b、根据索引添加 1234567891011121314151617181920212223242526272829303132333435/** * &lt;p&gt;根据索引添加元素&lt;/p&gt; * * @param element 数据 * @param index 索引 * @author Kallen * @since 2020/12/22 14:22*/public void insert(T element, int index) { // 索引小于0或大于当前链表最大索引长度 if (index &lt; 0 || index &gt; size -1) { throw new IndexOutOfBoundsException(&quot;索引越界&quot;); } // 是否为空链表 if (head == null) { OneLink(element); }else { // index是否为0 if (index == 0) { addAtHead(element); }else { // 获取插入点的前一个节点 Node prev = getNodeByIndex(index - 1); // 获取新节点 Node newNode = new Node(element); // prev的next指向新节点 prev.next = newNode; // 新节点的next指向原prev的next节点 newNode.next = prev.next; size++; } }} c、尾插法 123456789101112131415161718192021/** * &lt;p&gt;采用尾插法插入新节点&lt;/p&gt; * * @param element 数据 * @author Kallen * @since 2020/12/22 14:28*/public void add(T element) { // 该链表是否为空表 if (head == null) { OneLink(element); } else { // 新建Node结点 Node newNode = new Node(element); // 当前&quot;尾节点&quot;的&quot;指针&quot;指向&quot;新节点&quot; tail.next = newNode; // 以&quot;新节点&quot;作为&quot;尾结点&quot; tail = newNode; size++; }} d、头插法12345678910111213141516/** * &lt;p&gt;采用头插法插入新节点&lt;/p&gt; * * @param element 元素 * @author Kallen * @since 2020/12/22 14:16*/public void addAtHead(T element) { // 创建新节点，让新节点的next指向原head，并以新节点作为head head = new Node(element, head); // 如果插入之前是空链表 if (tail == null) { tail = head; } size++;} 5.3、查询数据a、根据索引查询1234567891011/** * &lt;p&gt;根据指定索引获取元素&lt;/p&gt; * * @param index 索引 * @return {@link T} 数据 * @author Kallen * @since 2020/12/22 13:55*/public T get(int index) { return getNodeByIndex(index).date;} b、根据指定元素查找索引1234567891011121314151617181920/** * &lt;p&gt;根据指定元素查找索引&lt;/p&gt; * * @param element 元素 * @return {@link int} 索引 * @author Kallen * @since 2020/12/22 14:06*/public int locate(T element) { // 从头结点开始搜索 Node current = head; for (int i = 0; i &lt; size &amp;&amp; current != null; i++, current = current.next) { if (current.date.equals(element)) { return i; } } return -1;} c、获取当前链表长度12345678910/** * &lt;p&gt;获取链表长度&lt;/p&gt; * * @return {@link int} 链表长度 * @author Kallen * @since 2020/12/23 13:34*/public int size() { return size;} 5.4、删除数据a、根据索引删除12345678910111213141516171819202122/** * &lt;p&gt;根据索引删除元素&lt;/p&gt; * * @param value 索引 * @author Kallen * @since 2020/12/22 14:34*/public void delete(int value) { if (value &lt; 0 || value &gt; size -1) { throw new IndexOutOfBoundsException(&quot;索引越界&quot;); } // 是否为head if (value == 0) { head = head.next; }else { // 获取指定删除节点的前一个节点 Node prev = getNodeByIndex(value - 1); // prev的next节点指向要删除节点的next prev.next = prev.next.next; } size--;} b、删除最后一个元素123456789/** * &lt;p&gt;删除最后一个元素&lt;/p&gt; * * @author Kallen * @since 2020/12/22 14:43*/public void remove() { delete(size -1);} 5.5、判断是否为空123456789/** * &lt;p&gt;是否为空&lt;/p&gt; * * @author Kallen * @since 2020/12/22 14:45*/public boolean isEmpty() { return size == 0;} 5.6、清空链表123456789101112/** * &lt;p&gt;清空链表&lt;/p&gt; * * @author Kallen * @since 2020/12/22 14:47 */public void clear() { // head、tail、size设置为空 head = null; tail = null; size = 0;} 5.7、私有方法123456789101112131415161718192021222324/** * &lt;p&gt;根据指定索引获取结点&lt;/p&gt; * * @param index 索引 * @return {@link OneLink&lt;T&gt;.Node} 结点 * @author Kallen * @since 2020/12/28 14:33*/private Node getNodeByIndex(int index) { // 判断指定位置是否合法 if (index &lt; 0 || index &gt; size - 1) { throw new IndexOutOfBoundsException(&quot;索引越界&quot;); } // 从head节点开始 Node current = head; for (int i = 0; i &lt; size &amp;&amp; current != null; i++, current = current.next) { if (i == index) { return current; } } return null;} &gt; 你知道越多，不知道的越多，感谢各位人才的：点赞、收藏和评论，我们下期见！","link":"/2020/12/28/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}